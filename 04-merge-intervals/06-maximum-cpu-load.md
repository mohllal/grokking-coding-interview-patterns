# Problem: Maximum CPU Load

GeekForGeek problem: [Maximum CPU load from the given list of jobs](https://www.geeksforgeeks.org/maximum-cpu-load-from-the-given-list-of-jobs/).

LeetCode problem with a similar idea: [1094. Car Pooling](https://leetcode.com/problems/car-pooling/).

We are given a list of Jobs. Each job has a start time, an end time, and a CPU load when it is running. Our goal is to find the maximum CPU load at any time if all the jobs are running on the same machine.

## Examples

Example 1:

```plaintext
Jobs: [[1,4,3], [2,5,4], [7,9,6]]
Output: 7
Explanation: Since [1,4,3] and [2,5,4] overlap, their maximum CPU load (3+4=7) will be when both the jobs are running at the same time i.e., during the time interval (2,4).
```

Example 2:

```plaintext
Jobs: [[6,7,10], [2,4,11], [8,12,15]]
Output: 15
Explanation: None of the jobs overlap, therefore we will take the maximum load of any job which is 15.
```

Example 3:

```plaintext
Jobs: [[1,4,2], [2,4,1], [3,6,5]]
Output: 8
Explanation: Maximum CPU load will be 8 as all jobs overlap during the time interval [3,4].
```

## Solution

This problem is quite similar to the [Minimum Meeting Rooms](./05-minimum-meeting-rooms.md) problem with the only difference being that, instead of tracking the number of jobs running simultaneously, we are concerned with the load generated by those jobs at any given time.

Complexity analysis:

- Time complexity: O(N * LogN)
- Space complexity: O(N)

```python
def findMaxCPULoad(jobs: List[List[int]]) -> int:
    jobs.sort(key=lambda job: (job[0], jobs[1]))
    
    max_load = 0
    curr_load = 0
    min_heap = [] # min heap which represents all ongoing jobs
    for i in range(len(jobs)):
        # remove all the jobs that have ended
        while len(min_heap) > 0 and jobs[i][0] >= min_heap[0][0]:
            curr_load -= min_heap[0][1]
            heapq.heappop(min_heap)
        
        # push end time and load for the current job into the min heap
        curr_load += jobs[i][2]
        heapq.heappush(min_heap, (jobs[i][1], jobs[i][2]))

        max_load = max(max_load, curr_load)

    return max_load <= capacity
```
